var documenterSearchIndex = {"docs":
[{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = ParametricGroebnerBases","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [ParametricGroebnerBases]","category":"page"},{"location":"reference/#ParametricGroebnerBases.CGB-Union{Tuple{Vector{RE}}, Tuple{RE}, Tuple{Vector{RE}, Any}} where RE<:AbstractAlgebra.Generic.MPoly","page":"Reference","title":"ParametricGroebnerBases.CGB","text":"CGB(F::Vector{RE}, reduced=true) where {RE<:MPoly}\n\nComputes a comprehensive parametric Gröbner basis of the ideal generated by F. In other words specialize.(G, Ref(α)) is a Gröbner basis for any vector α of appropriate length.\n\nIf the option reduced=true, then specialize.(G, Ref(α)) always contains the reduced Gröbner basis of the ideal generated by specialize.(F, Ref(α)).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParametricGroebnerBases.CGS-Union{Tuple{Vector{RE}}, Tuple{RE}, Tuple{Vector{RE}, Any}} where RE<:AbstractAlgebra.Generic.MPoly","page":"Reference","title":"ParametricGroebnerBases.CGS","text":"CGS(F::Vector{RE}, reduced=true) where {RE <: MPoly}\n\nFunction to compute reduced Gröbner systems. Returns a vector of triples of the form (S, [h], G). For any vector α such that specialize.(S, Ref(α)) == [0, 0, ..., 0] and specialize(h, α) != 0, specialize.(G, Ref(α)) is a reduced Gröbner basis.\n\nTakes the argument reduced. If set to false, the returned Gröbner basis will not be reduced.\n\nSee also [CGS_simple]\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParametricGroebnerBases.CGS_faithful-Union{Tuple{Vector{RE}}, Tuple{RE}, Tuple{Vector{RE}, Any}} where RE<:AbstractAlgebra.Generic.MPoly","page":"Reference","title":"ParametricGroebnerBases.CGS_faithful","text":"CGS_faithful(F::Vector{RE}, reduced=true) where {RE<:MPoly}\n\nFunction to compute faithful, reduced Gröbner systems. Returns a vector of triples of the form (S, [h], G). For any vector α such that specialize.(S, α) == [0, 0, ..., 0] and specialize(h, α) != 0, specialize.(G, Ref(α)) is a reduced Gröbner basis. Furthermore, each g ∈ G will belong to the ideal generated by F.\n\nTakes the argument reduced. If set to false, the returned Gröbner basis will not be reduced.\n\nSee also CGS_simple\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParametricGroebnerBases.CGS_simple-Union{Tuple{Vector{RE}}, Tuple{RE}} where RE<:AbstractAlgebra.Generic.MPoly","page":"Reference","title":"ParametricGroebnerBases.CGS_simple","text":"CGS_simple(F::Vector{RE}) where {RE <: MPoly}\n\nSimple function to compute Gröbner systems. Returns a vector of triples of the form (S, [h], G). For any vector α such that specialize.(S, Ref(α)) == [0, 0, ..., 0] and specialize(h, α) != 0, specialize.(G, Ref(α)) is a Gröbner basis.\n\nSee also CGS\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParametricGroebnerBases.pseudo_reduce-Union{Tuple{RE}, Tuple{RE, Any}, Tuple{RE, Any, Any}} where RE<:AbstractAlgebra.Generic.MPoly","page":"Reference","title":"ParametricGroebnerBases.pseudo_reduce","text":"pseudo_reduce(f::RE, G, reduced = false) where {RE<:MPoly}\n\nPseudo-reduces f modulo G = g_1 g_2 dots g_n. Pseudo-reduction writes\n\nc f = r + sum_i=1^n f_i g_i\n\nwhere c is a product of leading coefficients of G, operatornamelm(f_i g_i) leq operatornamelm(f), and no term of r is divisible by any leading monomial of G.\n\nThe result of pseudo_reduce(f, G) is the pair (c, r).\n\nTakes the argument reduced. If set to true, the function will remove factors in r  coming from  leading coefficients of G.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParametricGroebnerBases.pseudo_remainder-Union{Tuple{RE}, Tuple{RE, Any}, Tuple{RE, Any, Any}} where RE<:AbstractAlgebra.Generic.MPoly","page":"Reference","title":"ParametricGroebnerBases.pseudo_remainder","text":"pseudo_remainder(f::RE, G, reduced = false) where {RE<:MPoly}\n\nDefined as pseudo_reduce(f, G, reduced)[2].\n\nSee also pseudo_reduce\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParametricGroebnerBases.specialize-Union{Tuple{RE}, Tuple{RE, Any}} where RE<:AbstractAlgebra.Generic.MPoly","page":"Reference","title":"ParametricGroebnerBases.specialize","text":"specialize(f::RE, α) where {RE <: MPoly}\n\nSpecializes a polynomial to the given values.\n\nExamples\n\njulia> specialize(a*x + b^2*y, [2, 3])\n2*x + 9*y\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ParametricGroebnerBases","category":"page"},{"location":"#ParametricGroebnerBases","page":"Home","title":"ParametricGroebnerBases","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ParametricGroebnerBases. This is a package for computing and working with parametric Gröbner bases and Gröbner systems. ","category":"page"},{"location":"#Introduction-to-Gröbner-bases","page":"Home","title":"Introduction to Gröbner bases","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Gröbner bases are a fundamental technique in the study of polynomial ideals over fields. Let K be a field and let X = (x_1 x_2 dots x_n) be variables. A Gröbner basis is a finite subset G subseteq KX such that the ideal generated by leading terms of G is equal to the ideal generated by leading terms of the ideal generated by G.In other words, langle operatornamelt(G) rangle = langle operatornamelt(langle G rangle) rangle. G is called a Gröbner basis of an ideal I if langle G rangle = I.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Gröbner bases can be used to solve a variety of problems. Let's warm up with an example. Consider the unit circle centered at the origin. Does this circle intersect the line x = 1? Of course, the answer is yes, but let's see how Gröbner bases can tell ud the same thing.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The unit circle centered at the origin is described by the polynomial equation x^2 + y^2 - 1 = 0. The line x = 1 is described by x - 1 = 0. The two curves intersect if and only if there is a point (x_0 y_0) that satisfies both of these equations. If we compute a Gröbner basis of the ideal generated by those two polynomials, we get the following.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Nemo\njulia> using Groebner\n\njulia> R, (x, y) = QQ[:x, :y]\njulia> I = [x^2 + y^2 - 1, x - 1]\njulia> groebner(I)\n2-element Vector{QQMPolyRingElem}:\n y^2\n x - 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"This gives us an equivalent system, which is much easier to solve. We get (x_0 y_0) = (1 0), which is what we expected. What if I asked whether the line x = 3 intersected the circle? The answer is no. Using Gröbner bases, we get the equivalent system","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> I = [x^2 + y^2 - 1, x - 3]\njulia> groebner(I)\n2-element Vector{QQMPolyRingElem}:\n y^2 + 8\n x - 3","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since y^2 + 8 has no real solutions, the two curves do not intersect in the real plane. The situation is different in the complex plane, where there is in fact a solution to the system.","category":"page"},{"location":"#Introduction-to-parametric-Gröbner-bases","page":"Home","title":"Introduction to parametric Gröbner bases","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We could ask ourselves for which values of r and a the circle centered at the origin with radius r intersects the line x - a. To answer this, we can compute another Gröbner basis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> R, (x, y, r, a) = QQ[:x, :y, :r, :a]\njulia> I = [x^2 + y^2 - r^2, x - a]\njulia> groebner(I)\n2-element Vector{QQMPolyRingElem}:\n y^2 - r^2 + a^2\n x - a","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since the equation y^2 - r^2 + a^2 has a real solution if and only if -r^2 + a^2 geq 0, that answers the question. The two lines interesect exctly when r geq a. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, this doesn't always work. Let's look at a (slightly contrived) example. When does the line y = a x pass through the lines y = pm 1? The answer is, when a neq 0. Let us see if Gröbner bases tells us the same thing. Notice, that the two lines y = pm 1 can be described by the single polynomial equation y^2 - 1 = 0.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> R, (x, y, a) = QQ[:a, :x, :u]\njulia> I = [a*x - y, y^2 - 1]\n2-element Vector{QQMPolyRingElem}:\n y^2 - 1\n x*a - y","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is no longer easy to answer by looking at the equations independently. y^2 - 1 has the solutions pm 1, and ax - y always has the solution x = fracya, except when a = 0, then it's y = 0. However, we need to consider the two equations together to see that there is no solution for a = 0-","category":"page"},{"location":"","page":"Home","title":"Home","text":"To remedy this situation, we have Gröbner systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using ParametricGroebnerBases\n\njulia> R, (a, b) = QQ[:a, :b]\njulia> S, (x, y) = R[:x, :y]\njulia> I = [a*x - y, y^2 - 1]\njulia> CGS(I)\n2-element Vector{Tuple{Vector{AbstractAlgebra.Generic.MPoly{QQMPolyRingElem}}, Vector{AbstractAlgebra.Generic.MPoly{QQMPolyRingElem}}, Vector{AbstractAlgebra.Generic.MPoly{QQMPolyRingElem}}}}:\n ([], [a], [y^2 - 1, a*x - y])\n ([a], [1], [1])\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"The way to read this output is line by line. The first line reads \"when a neq 0, then the reduced Gröbner basis is given by y^2 - 1 ax - y\". In this case, we always have a solution. The second line reads \"when a = 0 and 1 neq 0, then the reduced Gröbner basis is given by 1\". Since there is no point (x_0 y_0) which satisfies the equation 1 = 0, there is no solution when a = 0.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"CurrentModule = ParametricGroebnerBases","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This page gives you two non-trivial examples, fully worked through, to demo the functionality of this package.","category":"page"},{"location":"example/#Example-1-–-Lotka-Volterra-equations","page":"Example","title":"Example 1 – Lotka-Volterra equations","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"The Lotka-Volterra equations are a simple example of a first order ODE with a periodic solution. The equations are as follows:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"$ \\frac{dx}{dt} = \\alpha x - \\beta x y $","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"$ \\frac{dy}{dt} = -\\gamma y + \\delta x y $","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"for some parameters alpha beta gamma and delta. Even though the ODE has a periodic solution, there is also a steady state. If x and y hits a certain value determined by the parameters, the system will remain at those values. We are interested in finding such a stady state. We note, that a steady state is reached when 0 = fracdxdt = alpha x - beta x y and 0 = fracdydt = -gamma y + delta x y.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"First, load Nemo for multivariate polynomials, and describe the ideal generated by the Lotka-Volterra equations:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"julia> using Nemo\njulia> using ParametricGroebnerBases\n\njulia> R, (α, β, γ, δ) = QQ[:α, :β, :γ, :δ]\njulia> S, (x, y) = R[:x, :y]\n\njulia> I = [α*x - β*x*y, -γ*y + δ*x*y]","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Now, we compute a parametric Gröbner system of this ideal.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"11-element Vector{Tuple{Vector{AbstractAlgebra.Generic.MPoly{QQMPolyRingElem}}, Vector{AbstractAlgebra.Generic.MPoly{QQMPolyRingElem}}, Vector{AbstractAlgebra.Generic.MPoly{QQMPolyRingElem}}}}:\n ([], [α*β*γ*δ], [β*γ*y^2 - α*γ*y, α*δ*x - β*γ*y])\n ([β*γ], [α*γ*δ], [α*γ*y, α*δ*x])\n ([β*γ, α*γ], [α*δ], [α*δ*x])\n ([β*γ, α*δ, α*γ], [δ], [δ*x*y - γ*y])\n ([δ, β*γ, α*γ], [γ], [γ*y])\n ([δ, γ], [β], [β*x*y - α*x])\n ([δ, γ, β], [α], [α*x])\n ([δ, γ, β, α], [1], [])\n ([β*γ, α*δ], [α*γ], [α*γ*y, α*γ*x])\n ([α*δ], [α*β*γ], [β*γ*y, α*γ*x])\n ([α*δ, α*γ], [β*γ], [β*γ*y])","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Each line of the output is a triple. Consider the second line","category":"page"},{"location":"example/","page":"Example","title":"Example","text":" ([β*γ], [α*γ*δ], [α*γ*y, α*δ*x])","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This states, that for any choice of parameters where beta gamma = 0 and alpha gamma delta neq 0, the reduced Gröbner basis of the ideal is alpha gamma y alpha delta x. We, however, are interested in the first line, the socalled generic case. It states, that whenever alpha beta gamma delta neq 0 (i.e. when none of them are zero), the reduced Gröbner basis of the ideal is given by","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"G =  beta gamma y^2 - alpha gamma y alpha delta x - beta gamma y","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Hence, we have a steady state whenever $ \\beta \\gamma y^2 - \\alpha \\gamma y = 0$ and alpha delta x - beta gamma y = 0. Notice, that the first polynomial is only in a single variable. Hence, we can solve this system by first solving for y, then substituting that into the second equation, and then solving for x. This a nice property of Gröbner bases. Whenever a system only has finitely many solutions, they can always be found in this way.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"To solve the system, first note that beta gamma y^2 - alpha gamma y = gamma y(beta y - alpha). This has two solutions, namely y = 0 and y = fracalphabeta. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Substituting y = 0 into alpha delta x - beta gamma y = 0 gives alpha delta x = 0, yielding the solution x = 0 y = 0. If we substitute y = fracalphabeta into alpha delta x - beta gamma y = 0, we get","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"alpha delta x - alpha gamma = 0","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"which has the solution (assuming alpha neq 0) x = fracgammadelta. Et voila, these are the steady states of the Lotka-Volterra equations. Obviously, solving the Lotka-Volterra equations directly is not difficult, but Gröbner basis methods scale well to more complicated polynomial systems.","category":"page"},{"location":"example/#Example-2-–-Orthic-triangles","page":"Example","title":"Example 2 – Orthic triangles","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"This example is this is taken from the article Gröbner bases for polynomial systems with parameters by Antonio Montes and Michael Wibmer.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Let A = (-1 0), B = (1 0) and C = (a b) be three points in the plane. They form the vertices of a triangle called ABC. Now, draw the heights of the triangle and find the points where they intersect the edges of the triangle. Call these points P_1 P_2 and P_3. This triangle P_1 P_2 P_3 is called the orthic triangle of ABC. See the figure.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"(Image: A triangle with its orthic triangle drawn)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"We wish to answer when the orthic triangle is isosceles with P_1 P_2 = P_1 P_3. To do this, we first produce an ideal, which describes the setup. First, we notice that the point P_1 = (a 0). Next, to encode that the line AC is orthoginal to the line B P_2, we need that their dotproduct is zero. Since the vector pointing from A to C is given by (-1 0) - (a b) = (a + 1 -b) and the line from B to P_2 is given by (1 0) - (x_2 y_2) = (x_2 - 1 -y_2), their dotproduct is (a + 1)(x2 - 1) + b y_2. Similarly, the dotproduct of BC and A P_3 is given by (a - 1)(x_3 + 1) + b y_3.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This only defines the lines that P_2 and P_3 lies on. To fix their absolute position, we encode that P_2 lines on the same line as AC. We have several ways of encoding this, but one is to say that the slope of line from A to C has to be equal to the slope of the line from A to P_2. The slope of the line from A to P_2 is fracy_21 + x_2 and the slope from A to C is fracba + 1. these two being equal is equivalent to 0 = b(1 + x_2) - (a + 1)y_2. Similarly, we get that 0 = b(x_3 - 1) - (a - 1)y_3.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Putting this all together, we can compute a Gröbner system of situation.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"julia> using Nemo\njulia> using ParametricGroebnerBases\n\njulia> R, (a, b) = QQ[:a, :b]\njulia> S, (x2, x3, y2, y3) = R[:x2, :x3, :y2, :y3]\n\njulia> I = [(a + 1)*(x2 - 1) + b*y2, (a - 1)*(x3 + 1) + b*y3, b*(1 + x2) - (a + 1)*y2, b*(x3 - 1) - (a - 1)*y3]\njulia> GS = CGS(I)\n12-element Vector{Tuple{Vector{AbstractAlgebra.Generic.MPoly{QQMPolyRingElem}}, Vector{AbstractAlgebra.Generic.MPoly{QQMPolyRingElem}}, Vector{AbstractAlgebra.Generic.MPoly{QQMPolyRingElem}}}}:\n ([], [a^4*b + 2*a^2*b^3 - 2*a^2*b + b^5 + 2*b^3 + b], [(a^2 - 2*a + b^2 + 1)*y3 + 2*a*b - 2*b, (a^2 + 2*a + b^2 + 1)*y2 - 2*a*b - 2*b, (a^2*b - 2*a*b + b^3 + b)*x3 + a^2*b - 2*a*b - b^3 + b, (a^2*b + 2*a*b + b^3 + b)*x2 - a^2*b - 2*a*b + b^3 - b])\n ([a^2 - 2*a + b^2 + 1], [b^2], [b^2])\n ([b^2, a^2 - 2*a + 1], [a*b - b], [a*b - b])\n ([b^2, a*b - b, a^2 - 2*a + 1], [b], [y2 - b, b*x3 + (-a + 1)*y3 - b, x2 - 1])\n ([b, a^2 - 2*a + 1], [a - 1], [(a - 1)*y3, y2, (a - 1)*x3 + a - 1, x2 - 1])\n ([b, a - 1], [1], [y2, x2 - 1])\n ([a^2 + 2*a + b^2 + 1], [b^2], [b^2])\n ([b^2, a^2 + 2*a + 1], [a*b + b], [a*b + b])\n ([b^2, a*b + b, a^2 + 2*a + 1], [b], [y3 - b, x3 + 1, b*x2 + (-a - 1)*y2 + b])\n ([b, a^2 + 2*a + 1], [a + 1], [y3, (a + 1)*y2, x3 + 1, (a + 1)*x2 - a - 1])\n ([b, a + 1], [1], [y3, x3 + 1])\n ([b], [a^2 - 1], [(a - 1)*y3, (a + 1)*y2, (a - 1)*x3 + a - 1, (a + 1)*x2 - a - 1])","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Now, we need to determine whether P_1 P_2 = P_1 P_3 follows from these assumptions. First, we inspect the segments of the Gröbner system. Some of the segments contain contradicting conditions, but almost all of them forces b = 0. The only interesting segment is the first one. It turns out that the only condition placed on this segment is that b neq 0, which excludes the degenerate triangle. This is fine for our purposes. Hence, we can extract the Gröbner basis of that segment.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"julia> G = GS[1][3]\n4-element Vector{AbstractAlgebra.Generic.MPoly{QQMPolyRingElem}}:\n (a^2 - 2*a + b^2 + 1)*y3 + 2*a*b - 2*b\n (a^2 + 2*a + b^2 + 1)*y2 - 2*a*b - 2*b\n (a^2*b - 2*a*b + b^3 + b)*x3 + a^2*b - 2*a*b - b^3 + b\n (a^2*b + 2*a*b + b^3 + b)*x2 - a^2*b - 2*a*b + b^3 - b\n","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"For now, let a and b be two fixed real numbers. To figure out whether P_1 P_2 = P_1 P_3, we construct a polynomial describing this equality. It is given by f = (x_3 - a)^2 + y_3^2 - (x_2 - a)^2 - y_2^2. That fact that P_1 P_2 = P_1 P_3 is equivalent to deciding if f lies in the radical of I. Since I has dimension 1, it is not hard to see that the radical of I is equal to I. Hence, we just need that f lies in I. Letting a and b return to being variables, we need to figure out for which choices of a and b, f lies in I. We can find sufficient and nessecary conditions for this using pseudo-division:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"julia> f = (x3 - a)^2 + y3^2 - (x2 - a)^2 - y2^2\njulia> r = pseudo_reduce(f, G)[2]\njulia> factor(r)\n4 * (a^2 + b^2 - 1) * a * b^4 * (a^2 - b^2 - 1) * (a^2 + 2*a + b^2 + 1)^3 * (a^2 - 2*a + b^2 + 1)^3","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The pseudo-remainder satisfies, that f lies in I for a given choice of a and b if and only if the pseudo-remainder is zero for that choice. From this we can see that P_1 P_2 = P_1 P_3 if either a^2 + b^2 - 1 = 0, a = 0, b = 0, a^2 - b^2 - 1 = 0 or two more complicated polynomials are zero. The two more complicated polynomials can not be zero and neither can b by the conditions on the segment. All those cases would lead to a degenerate triangle. But the three remaining cases all give ways of making the orthic triangle isosceles. The following figure illustrates exactly the points, where P_1 P_2 = P_1 P_3.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"(Image: The complete set of points, where the orthic triangle is isosceles)","category":"page"}]
}
